# 05. 트리(Tree)와 우선순위 큐(Priority Queue)

우선순위 큐 → 최단거리

## 트리

- 트는 가계도와 같이 계층적인 구조를 표현할 때 사용할 수 있는 자료구조
- 나무의 형태를 뒤집은 것과 같이 생겼다.
    
    ![스크린샷 2023-10-02 오후 8.51.34.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/84863426-31c9-4f36-9772-775b1b68d7f3/e83170e4-a863-467c-bfbe-c71556de6dd5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.51.34.png)
    
- 트리에서는 부모와 자식 관계가 성립한다.
- 형제 관계가 성립한다.
- 깊이: 루트 노드에서의 길이(length)
- 이때 길이란 출발 노드에서 목적지 노드까지 거쳐야 하는 간선의 수를 의미한다.
- 트리의 높이는 루트 노드에서 가장 깊은 노드까지의 길이를 의미한다.

## 이진트리(Binary Tree)

- 이진 트리는 최대 2개의 자식을 가질 수 있는 트리를 말한다.

## 우선순위 큐(priority Queue)

- 우선순위 큐는 우선순위에 따라서 데이터를 추출하는 자료구조다.
- 컴퓨터 운영체제, 온라인 게임 매칭 등에서 활용된다.
- 우선순위 큐는 일반적으로 힙(트리 자료구조를 이용해서 만들 수 있는 자료구조)을 이용해 구현한다.

| 자료구조 | 추출되는 데이터 |
| --- | --- |
| stack | 가장 나중에 삽입된 데이터 |
| queue | 가장 먼저 삽입된 데이터 |
| Priority queue | 가장 우선순위가 높은 데이터 |

## 우선순위 큐를 구현하는 방법

- 우선순위 큐는 다양한 방법으로 구현할 수 있다.
- 데이터의 개수가 N개일 때, 구현 방식에 따른 시간 복잡도는 다음과 같다

| 우선순위 큐 구현 방식 | 삽입 시간 | 삭제 시간 |
| --- | --- | --- |
| 리스트 자료형 | O(1) | O(N) |
| 힙(Heap) | O(logN) | O(logN) |

⇒ 힙 자료구조를 사용하는 이유

- 일반적인 형태의 큐는 선형적인 구조를 가진다.
- 반면에 우선순위 큐는 이진트리 구조를 사용하는 것이 일반적이다.

![스크린샷 2023-10-02 오후 9.02.43.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/84863426-31c9-4f36-9772-775b1b68d7f3/f1b1dd9f-d4ce-4cdb-a342-7b881bc9f79a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.02.43.png)

## 포화 이진 트리

- 포화 이진 트리는 리프 노드를 제외한 모든 노드가 두 자식을 가지고 있는 트리다.
    
    ![스크린샷 2023-10-02 오후 9.03.47.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/84863426-31c9-4f36-9772-775b1b68d7f3/56da02d9-c0b4-4eab-9b9b-5b35fec7a460/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.03.47.png)
    

## 완전 이진 트리

- 완전 이진 트리는 모든 노드가 왼쪽 자식부터 차근차근 채워진 트리다.

![스크린샷 2023-10-02 오후 9.04.52.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/84863426-31c9-4f36-9772-775b1b68d7f3/32354740-3107-43ed-995f-5b94e20ed122/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.04.52.png)

- 위치가 정해져 있는 노드

## 높이 균형 트리

- 왼쪽 자식 트리와 오른쪽 자식 트리의 높이가 1이상 차이나지 않는 트리다.

![스크린샷 2023-10-02 오후 9.06.02.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/84863426-31c9-4f36-9772-775b1b68d7f3/784f08e8-48ac-49dd-8ace-93b7533068e6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.06.02.png)

## 힙(Heap)

- 힙은 원소들 중에서 최댓값 혹은 최솟값을 빠르게 찾아내는 자료구조다.
- 최대 힙(max heap): 값이 큰 원소부터 추출한다.
- 최소 힙(min heap): 값이 작은 원소부터 추출한다.
- 힙은 원소의 삽입과 삭제를 위해 **O(logN)**의 수행 시간을 요구한다. → 완전 이진트리를 이용하기 때문에
- 단순한 N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일하다.
- 이 경우 시간 복잡도는 O(NlogN)이다.

## 최대 힙(Max Heap)

- 최대 힙은 부모노드가 자식 노드보다 값이 큰 **완전 이진트리**를 의미한다.
- 최대 힙의 루트 노드는 전체 트리에서 가장 큰 값을 가진다는 특징이 있다.

## 힙의 특징

- 힙은 완전 이진 트리 자료구조를 따른다.
- 힙에서는 우선순위가 높은 노드가 루트에 위치한다.
1. 최대 힙
- 부모 노드의 키 값이 자식 노드의 키 값보다 항상 크다.
- 루트 노드가 가장 크며, 값이 큰 데이터가 우선순위를 가진다.
1. 최소 힙
- 부모 노드의 키 값이 자식 노드의 키 값보다 항상 작다.
- 루트 노드가 가장 작으며, 값이 작은 데이터가 우선순위를 가진다.

## 최소 힙 구성 함수 : Heapify

![스크린샷 2023-10-02 오후 9.16.59.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/84863426-31c9-4f36-9772-775b1b68d7f3/59113cfe-1428-4153-aa39-ec825e56ee12/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.16.59.png)

## 힙에 새로운 원소가 삽입될 때

![스크린샷 2023-10-02 오후 9.19.42.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/84863426-31c9-4f36-9772-775b1b68d7f3/63035f46-f3c1-4a66-8f8b-a6c57fe82170/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.19.42.png)

## 힙에 새로운 원소가 삭제될 때

![스크린샷 2023-10-02 오후 9.20.05.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/84863426-31c9-4f36-9772-775b1b68d7f3/b3f9c10f-2769-4f7e-b534-a119f5cf1e3f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.20.05.png)

## 힙의 특징

- 힙의 삽입과 삭제 연산을 수행할 때를 고려해보자
- 직관적으로, 거슬러 갈 떄마다 처리해야 하는 범위에 포함된 우너소의 개수가 절반씩 줄어든다
- 따라서 삽입과 삭제에 대한 시간 복잡도는 O(logN)이다.

## JavaScript 힙 라이브러리

- JavaScript는 기본적으로 우선순위 큐를 라이브러리로 제공하지 않는다.
- 최단 경로 알고리즘 등에서 힙이 필요한 경우 별도의 라이브러리를 사용해야한다.

```jsx
// 최대힙
let pq = new PriorityQueue(function(a,b){
	return a.cash - b.cash;
});

pq.enq({cash: 250, name: 'Doohyun Kim'});
pq.enq({cash: 300, name: 'Gildong Hong'});
pq.enq({cash: 150, name: 'Minchul Han'});
console.log(pq.size()); // 3
console.log(pq.deq()); // {cash: 300, name: 'Gildong Hong'}
console.log(pq.peek()); // {cash: 250, name: 'Doohyun Kim'}
console.log(pq.size()); // 2
```

https://github.com/ndb796/priorityqueuejs
